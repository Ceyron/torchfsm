from .operator import Laplacian, ImplicitSource, ExplicitSource, Operator
from .mesh import FourierMesh, MeshGrid, mesh_shape
from ._type import SpatialTensor
from .utils import clean_up_memory
from torch import Tensor
import torch
from typing import Union, Sequence, Optional,Literal, Tuple

def normalize(
    u: Union[SpatialTensor["B C H ..."],SpatialTensor["B C H ..."]],
    normalize_mode=Literal["normal_distribution","-1_1","0_1"]
    ):
    if normalize_mode not in ["normal_distribution","-1_1","0_1"]:
        raise ValueError(f"normalize_mode must be one of ['normal_distribution','-1_1','0_1'], but got {normalize_mode}")
    if normalize_mode == "normal_distribution":
        u = u - u.mean(dim=[i for i in range(1,u.ndim)],keepdim=True)
        u = u / u.std(dim=[i for i in range(1,u.ndim)],keepdim=True)
        return u
    else:
        shape=[u.shape[0]]+[1]*(len(u.shape)-1)
        max_v=torch.max(u.view(u.size(0), -1), dim=1).values.view(shape)
        min_v=torch.min(u.view(u.size(0), -1), dim=1).values.view(shape)
        u = (u - min_v) / (max_v - min_v)
        if normalize_mode == "-1_1":
            u = u * 2 - 1
        return u

def diffused_noise(
    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],
    diffusion_coef: float = 1.0,
    device: Optional[torch.device] = None,
    dtype: Optional[torch.dtype] = None,
    batch_size: int = 1,
    n_channel: int = 1,
    normalize_mode:Optional[Literal["normal_distribution","-1_1","0_1"]]=None,
) -> SpatialTensor["B C H ..."]:
    r"""
    Generate a diffused noise field.
        The noise is generated by integrating a Laplacian operator with a random initial condition.
        The diffusion coefficient controls the amount of diffusion applied to the noise.
    
    Args:
        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): The mesh to generate the noise on.
            If a sequence is provided, it should be in the form of [(x_min, x_max, n_points), ...].
        diffusion_coef (float): The diffusion coefficient. Default is 1.0.
        device (Optional[torch.device]): The device to generate the noise on. Default is None.
        dtype (Optional[torch.dtype]): The data type of the generated noise. Default is None.
        batch_size (int): The number of batches. Default is 1.
        n_channel (int): The number of channels. Default is 1.
        normalize_mode (Optional[Literal["normal_distribution","-1_1","0_1"]]): The normalization mode for the generated noise.
            If None, no normalization is applied. Default is None.

    Returns:
        SpatialTensor["B C H ...]: The generated diffused noise field.
    """
    if device is None and (isinstance(mesh, FourierMesh) or isinstance(mesh, MeshGrid)):
        device = mesh.device
    if dtype is None and (isinstance(mesh, FourierMesh) or isinstance(mesh, MeshGrid)):
        dtype = mesh.dtype
    u_0 = torch.randn(
        *mesh_shape(mesh, batch_size=batch_size, n_channel=n_channel),
        device=device,
        dtype=dtype
    )
    diffusion = diffusion_coef * Laplacian()
    u_0 = diffusion.integrate(u_0, dt=1, step=1, mesh=mesh)
    del diffusion
    clean_up_memory()
    if normalize_mode is not None:
        u_0 = normalize(u_0, normalize_mode=normalize_mode)
    return u_0

def truncated_fourier_series(
    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],
    freq_threshold: int = 5,
    amplitude_range: tuple[int, int] = (-1.0, 1.0),
    angle_range: tuple[int, int] = (0.0, 2.0 * torch.pi),
    device: Optional[torch.device] = None,
    dtype: Optional[torch.dtype] = None,
    batch_size: int = 1,
    n_channel: int = 1,
    normalize_mode=Optional[Literal["normal_distribution","-1_1","0_1"]],
) -> SpatialTensor["B C H ..."]:
    r"""
    Generate a truncated Fourier series noise field on a given mesh.
    
    Args:
        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): The mesh on which to generate the noise.
        freq_threshold (int): The frequency threshold for truncation.
        amplitude_range (tuple[int, int]): The range of amplitudes for the noise.
        angle_range (tuple[int, int]): The range of angles for the noise.
        device (Optional[torch.device]): The device on which to create the tensor.
        dtype (Optional[torch.dtype]): The data type of the tensor.
        batch_size (int): The number of batches.
        n_channel (int): The number of channels.
        normalize_mode (Optional[Literal["normal_distribution","-1_1","0_1"]]): The normalization mode for the generated noise.
            If None, no normalization is applied. Default is None.
    
    Returns:
        SpatialTensor["B C H ..."]: The generated noise field.
    """
    if device is None and (isinstance(mesh, FourierMesh) or isinstance(mesh, MeshGrid)):
        device = mesh.device
    if dtype is None and (isinstance(mesh, FourierMesh) or isinstance(mesh, MeshGrid)):
        dtype = mesh.dtype
    if not isinstance(mesh, FourierMesh):
        mesh = FourierMesh(mesh, device=device, dtype=dtype)
    
    magnitude=torch.rand(
        *mesh_shape(mesh, batch_size=batch_size, n_channel=n_channel),
        device=device,
        dtype=dtype
    )* (amplitude_range[1] - amplitude_range[0]) + amplitude_range[0]   
    angle=torch.rand(
        *mesh_shape(mesh, batch_size=batch_size, n_channel=n_channel),
        device=device,
        dtype=dtype
    )* (angle_range[1] - angle_range[0]) + angle_range[0]
    fourier_noise = magnitude * torch.exp(1j * angle)
    fourier_noise = fourier_noise * mesh.abs_low_pass_filter(freq_threshold)
    mesh.abs_low_pass_filter.cache_clear()
    fourier_noise = mesh.ifft(fourier_noise).real
    if normalize_mode is not None:
        fourier_noise = normalize(fourier_noise, normalize_mode=normalize_mode)
    return fourier_noise

def kolm_force(
    x: torch.Tensor,
    drag_coef: float = -0.1,
    k: float = 4.0,
    length_scale: float = 1.0,
) -> Operator:
    r"""
    Generate cosine force field for 2d kolmogorov flow in vorticity form.
        It is defined as $a \omega - k cos (k l x)$

    Args:
        x (torch.Tensor): The input tensor.
        drag_coef (float): The drag coefficient $a$. Default is -0.1.
        k (float): The wave number. Default is 4.0.
        length_scale (float): The length scale $l$. Default is 1.0.
    """


    return drag_coef * ImplicitSource() - ExplicitSource(
        k * torch.cos(k * length_scale * x)
    )

def wave_1d(
    x: SpatialTensor["B C H ..."],
    min_k: int = 1,
    max_k: int = 5,
    min_amplitude: float = 0.5,
    max_amplitude: float = 1.0,
    n_polynomial: int = 5,
    zero_mean: bool = False,
    mean_shift_coef=0.3,
    batched: bool = False,
) -> SpatialTensor["B C H ..."]:
    r"""
    Generate a 1D wave field with multiple harmonics.

    Args:
        x (SpatialTensor["B C H ..."]): The input tensor.
        min_k (int): The minimum wave number. Default is 1.
        max_k (int): The maximum wave number. Default is 5.
        min_amplitude (float): The minimum amplitude. Default is 0.5.
        max_amplitude (float): The maximum amplitude. Default is 1.0.
        n_polynomial (int): The number of polynomial terms. Default is 5.
        zero_mean (bool): If True, the mean of the wave will be zero. Default is False.
        mean_shift_coef (float): The coefficient for mean shift. Default is 0.3.
        batched (bool): If True, the input tensor is batched. Default is False.
    
    Returns:
        SpatialTensor["B C H ..."]: The generated wave field.
    """
    x_new = x / x.max() * torch.pi * 2
    y = torch.zeros_like(x)
    if not batched:
        x_new = x_new.unsqueeze(0)
        y = y.unsqueeze(0)
    batch = x_new.shape[0]
    shape = [batch, n_polynomial] + [1] * (x_new.dim() - 2)
    k = torch.randint(min_k, max_k + 1, shape, device=x.device, dtype=x.dtype)
    amplitude = (
        torch.rand(*shape, device=x.device, dtype=x.dtype)
        * (max_amplitude - min_amplitude)
        + min_amplitude
    )
    shift = torch.rand(*shape, device=x.device, dtype=x.dtype) * torch.pi * 2
    for i in range(n_polynomial):
        y += amplitude[:, i : i + 1, ...] * torch.sin(
            k[:, i : i + 1, ...] * (x_new + shift[:, i : i + 1, ...])
        )
    if not zero_mean:
        value_shift = torch.rand(
            [batch] + [1] * (x_new.dim() - 1), device=x.device, dtype=x.dtype
        )
        value_shift = (value_shift - 0.5) * 2 * (
            max_amplitude - min_amplitude
        ) * mean_shift_coef + min_amplitude
        y += value_shift
    if not batched:
        y = y.squeeze(0)
    return y

def _mahalanobis_distance(
    locations: Tensor, 
    mean: torch.Tensor,
    variance: torch.Tensor,
):
    r"""
    Calculate the Mahalanobis distance at given locations.

    Args:
        locations (Tensor): The locations where the PDF is evaluated Shape should be (C, X, Y, Z, ...) where C is number of dimensions and X, Y, Z are additional dimensions.
        position (torch.Tensor): The mean position of the Gaussian distribution. The shape should be (C,).
        variance (torch.Tensor): The variance of the Gaussian distribution. The shape should be (C,).

    Returns:
        Tensor: The Mahalanobis distance at the specified locations, shape (X, Y, Z, ...).
    """
    k=locations.shape[0]
    if mean.ndim != 1 or variance.ndim != 1:
        raise ValueError("mean and variance must be 1-dimensional tensors.")
    if mean.shape[0] != k or variance.shape[0] != k:
        raise ValueError(f"mean and variance must have {k} elements, but got {mean.shape[0]} and {variance.shape[0]} respectively.")
    diff = locations - mean.view(-1, *((1,) * (locations.ndim - 1)))
    inv_covariance = torch.linalg.inv(torch.diag_embed(variance))
    return torch.einsum("i...,ij,j...->...", diff, inv_covariance, diff)

_batched_mahalanobis_distance = torch.vmap(_mahalanobis_distance)

def random_gaussian_blobs(
    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],
    position_range: Tuple[float, float] = (0.4, 0.6),
    variance_range: Tuple[float, float] = (0.005, 0.01),
    batch_size: int = 1,
    n_channels: int = 1,
    device: Optional[torch.device] = None
) -> SpatialTensor["B C H ..."]:
    r"""
    Generate random Gaussian blobs on the specified mesh.
    
    Args:
        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]):
            The mesh on which to generate the Gaussian blob.
        position_range (Tuple[float, float]): The range of positions for the Gaussian blob.
            Default is (0.4, 0.6).
        variance_range (Tuple[float, float]): The range of variances for the Gaussian blob.
            Default is (0.005, 0.01).
        batch_size (int): The number of batches. Default is 1.
        n_channels (int): The number of channels. Default is 1.
        device (Optional[torch.device]): The device on which to create the tensor. Default is None. 
        
    Returns:
        SpatialTensor["B C H ..."]: The generated Gaussian blob field.
    """
    if not isinstance(mesh, MeshGrid):
        mesh = MeshGrid(mesh.mesh_info if isinstance(mesh, FourierMesh) else mesh,device=device)
    if device is not None:
        if mesh.device != device:
            raise ValueError(f"Mesh device {mesh.device} does not match the specified device {device}.")
    mesh_grid= mesh.bc_mesh_grid()
    mesh_grid = [mesh_grid] if isinstance(mesh_grid, Tensor) else mesh_grid
    locations=torch.cat(mesh_grid,dim=1).squeeze(0)
    n_dim = locations.ndim-1 
    position = torch.empty(n_dim).uniform_(position_range[0],position_range[1]).to(mesh.device)
    variance = torch.empty(n_dim).uniform_(variance_range[0], variance_range[1]).to(mesh.device)
    locations = torch.stack([locations]*batch_size*n_channels, dim=0)
    position = position.unsqueeze(0).repeat(batch_size*n_channels, 1)
    variance = variance.unsqueeze(0).repeat(batch_size*n_channels, 1)
    blob=torch.exp(-0.5*_batched_mahalanobis_distance(locations, position, variance))
    return blob.view(batch_size, n_channels, *blob.shape[1:])
